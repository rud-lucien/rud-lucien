//=============================================================================
// COMMAND SIMULATION TEST HARNESS
// Tests command parsing and routing without requiring ClearCore hardware
//=============================================================================

#include <iostream>
#include <string>
#include <cstring>
#include <vector>

// Mock Arduino types and functions
typedef unsigned char uint8_t;

// Mock Stream class
class MockStream {
public:
    std::string output;
    
    size_t write(uint8_t c) {
        output += (char)c;
        return 1;
    }
    
    size_t write(const uint8_t *buffer, size_t size) {
        for (size_t i = 0; i < size; i++) {
            output += (char)buffer[i];
        }
        return size;
    }
    
    void println(const char* str) {
        output += str;
        output += "\n";
    }
    
    void print(const char* str) {
        output += str;
    }
    
    int available() { return 0; }
    int read() { return -1; }
    int peek() { return -1; }
    void flush() {}
};

// Mock CommandCaller class
class CommandCaller {
public:
    virtual size_t write(uint8_t c) = 0;
    virtual size_t write(const uint8_t *buffer, size_t size) = 0;
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;
    
    void println(const char* str) {
        print(str);
        write('\n');
    }
    
    void print(const char* str) {
        write((const uint8_t*)str, strlen(str));
    }
};

// Mock StreamCommandCaller
class MockCommandCaller : public CommandCaller {
private:
    MockStream* stream;
public:
    MockCommandCaller(MockStream* s) : stream(s) {}
    
    size_t write(uint8_t c) override {
        return stream->write(c);
    }
    
    size_t write(const uint8_t *buffer, size_t size) override {
        return stream->write(buffer, size);
    }
    
    int available() override { return 0; }
    int read() override { return -1; }
    int peek() override { return -1; }
    void flush() override {}
};

//=============================================================================
// MOCK COMMAND FUNCTIONS - These simulate the actual cmd_* functions
//=============================================================================

bool cmd_rail1(char *args, CommandCaller *caller) {
    caller->print("RAIL1 EXECUTED: ");
    caller->println(args);
    
    // Parse different rail1 subcommands
    if (strstr(args, "home")) {
        caller->println("  -> Executing rail1 home operation");
    }
    else if (strstr(args, "move-wc1")) {
        caller->println("  -> Executing rail1 move to WC1");
        if (strstr(args, "with-labware")) {
            caller->println("  -> With labware handling");
        } else {
            caller->println("  -> No labware handling");
        }
    }
    else if (strstr(args, "move-wc2")) {
        caller->println("  -> Executing rail1 move to WC2");
    }
    else if (strstr(args, "move-staging")) {
        caller->println("  -> Executing rail1 move to staging");
    }
    else if (strstr(args, "move-handoff")) {
        caller->println("  -> Executing rail1 move to handoff");
    }
    else if (strstr(args, "move-mm-to")) {
        caller->println("  -> Executing rail1 absolute move");
    }
    else if (strstr(args, "move-rel")) {
        caller->println("  -> Executing rail1 relative move");
    }
    else if (strstr(args, "status")) {
        caller->println("  -> Executing rail1 status query");
    }
    else if (strstr(args, "help")) {
        caller->println("  -> Executing rail1 help display");
    }
    else {
        caller->println("  -> Unknown rail1 subcommand");
    }
    
    return true;
}

bool cmd_rail2(char *args, CommandCaller *caller) {
    caller->print("RAIL2 EXECUTED: ");
    caller->println(args);
    
    if (strstr(args, "init")) {
        caller->println("  -> Executing rail2 initialization");
    }
    else if (strstr(args, "clear-fault")) {
        caller->println("  -> Executing rail2 fault clear");
    }
    else if (strstr(args, "abort") || strstr(args, "stop")) {
        caller->println("  -> Executing rail2 emergency stop");
    }
    else if (strstr(args, "extend")) {
        caller->println("  -> Executing rail2 extend");
    }
    else if (strstr(args, "retract")) {
        caller->println("  -> Executing rail2 retract");
    }
    else if (strstr(args, "home")) {
        caller->println("  -> Executing rail2 home operation");
    }
    else if (strstr(args, "move-wc3")) {
        caller->println("  -> Executing rail2 move to WC3");
    }
    else if (strstr(args, "move-handoff")) {
        caller->println("  -> Executing rail2 move to handoff");
    }
    else if (strstr(args, "move-mm-to")) {
        caller->println("  -> Executing rail2 absolute move");
    }
    else if (strstr(args, "move-rel")) {
        caller->println("  -> Executing rail2 relative move");
    }
    else if (strstr(args, "status")) {
        caller->println("  -> Executing rail2 status query");
    }
    else if (strstr(args, "help")) {
        caller->println("  -> Executing rail2 help display");
    }
    
    return true;
}

bool cmd_teach(char *args, CommandCaller *caller) {
    caller->print("TEACH EXECUTED: ");
    caller->println(args);
    
    if (strstr(args, "status")) {
        caller->println("  -> Executing teach status query");
    }
    else if (strstr(args, "reset")) {
        caller->println("  -> Executing teach reset");
    }
    else {
        caller->println("  -> Executing teach position recording");
    }
    
    return true;
}

bool cmd_network(char *args, CommandCaller *caller) {
    caller->print("NETWORK EXECUTED: ");
    caller->println(args);
    
    if (strstr(args, "status")) {
        caller->println("  -> Executing network status query");
    }
    else if (strstr(args, "disconnect")) {
        caller->println("  -> Executing network disconnect");
    }
    else if (strstr(args, "help")) {
        caller->println("  -> Executing network help display");
    }
    
    return true;
}

bool cmd_jog(char *args, CommandCaller *caller) {
    caller->print("JOG EXECUTED: ");
    caller->println(args);
    
    if (strstr(args, "+")) {
        caller->println("  -> Executing positive jog");
    }
    else if (strstr(args, "-")) {
        caller->println("  -> Executing negative jog");
    }
    else if (strstr(args, "increment")) {
        caller->println("  -> Executing jog increment setting");
    }
    else if (strstr(args, "speed")) {
        caller->println("  -> Executing jog speed setting");
    }
    else if (strstr(args, "status")) {
        caller->println("  -> Executing jog status query");
    }
    else if (strstr(args, "help")) {
        caller->println("  -> Executing jog help display");
    }
    
    return true;
}

bool cmd_encoder(char *args, CommandCaller *caller) {
    caller->print("ENCODER EXECUTED: ");
    caller->println(args);
    
    if (strstr(args, "enable")) {
        caller->println("  -> Executing encoder enable");
    }
    else if (strstr(args, "disable")) {
        caller->println("  -> Executing encoder disable");
    }
    else if (strstr(args, "multiplier")) {
        caller->println("  -> Executing encoder multiplier setting");
    }
    else if (strstr(args, "velocity")) {
        caller->println("  -> Executing encoder velocity setting");
    }
    else if (strstr(args, "status")) {
        caller->println("  -> Executing encoder status query");
    }
    else if (strstr(args, "help")) {
        caller->println("  -> Executing encoder help display");
    }
    
    return true;
}

bool cmd_system(char *args, CommandCaller *caller) {
    caller->print("SYSTEM EXECUTED: ");
    caller->println(args);
    
    if (strstr(args, "state")) {
        caller->println("  -> Executing system state query");
    }
    else if (strstr(args, "home")) {
        caller->println("  -> Executing system home");
    }
    else if (strstr(args, "reset")) {
        caller->println("  -> Executing system reset");
    }
    else if (strstr(args, "help")) {
        caller->println("  -> Executing system help display");
    }
    
    return true;
}

bool cmd_goto(char *args, CommandCaller *caller) {
    caller->print("GOTO EXECUTED: ");
    caller->println(args);
    
    if (strstr(args, "wc1")) {
        caller->println("  -> Executing goto WC1");
    }
    else if (strstr(args, "wc2")) {
        caller->println("  -> Executing goto WC2");
    }
    else if (strstr(args, "wc3")) {
        caller->println("  -> Executing goto WC3");
    }
    else if (strstr(args, "help")) {
        caller->println("  -> Executing goto help display");
    }
    
    return true;
}

bool cmd_labware(char *args, CommandCaller *caller) {
    caller->print("LABWARE EXECUTED: ");
    caller->println(args);
    
    if (strstr(args, "status")) {
        caller->println("  -> Executing labware status query");
    }
    else if (strstr(args, "audit")) {
        caller->println("  -> Executing labware audit");
    }
    else if (strstr(args, "reset")) {
        caller->println("  -> Executing labware reset");
    }
    else if (strstr(args, "help")) {
        caller->println("  -> Executing labware help display");
    }
    
    return true;
}

bool cmd_log(char *args, CommandCaller *caller) {
    caller->print("LOG EXECUTED: ");
    caller->println(args);
    
    if (strstr(args, "on")) {
        caller->println("  -> Executing log enable");
    }
    else if (strstr(args, "off")) {
        caller->println("  -> Executing log disable");
    }
    else if (strstr(args, "now")) {
        caller->println("  -> Executing log now");
    }
    else if (strstr(args, "history")) {
        caller->println("  -> Executing log history");
    }
    else if (strstr(args, "errors")) {
        caller->println("  -> Executing log errors");
    }
    else if (strstr(args, "last")) {
        caller->println("  -> Executing log last entries");
    }
    else if (strstr(args, "stats")) {
        caller->println("  -> Executing log stats");
    }
    else if (strstr(args, "help")) {
        caller->println("  -> Executing log help display");
    }
    
    return true;
}

bool cmd_print_help(char *args, CommandCaller *caller) {
    caller->println("HELP EXECUTED");
    caller->println("  -> Displaying system help information");
    return true;
}

//=============================================================================
// COMMAND EXECUTION SIMULATION - Copy of the actual executeCommand logic
//=============================================================================

bool simulateExecuteCommand(const char *command, MockStream *output) {
    char firstWord[16] = {0};
    int i = 0;
    while (command[i] && command[i] != ',' && command[i] != ' ' && i < 15)
    {
        firstWord[i] = command[i];
        i++;
    }
    firstWord[i] = '\0';

    // Calculate args pointer (skip "command,")
    const char* argsStart = strchr(command, ',');
    char* args = const_cast<char*>(argsStart ? argsStart + 1 : "");
    
    MockCommandCaller caller(output);

    // Dispatch to appropriate command function - EXACT COPY from CommandController.cpp
    bool success = false;
    
    if (strcmp(firstWord, "rail1") == 0) {
        success = cmd_rail1(args, &caller);
    }
    else if (strcmp(firstWord, "rail2") == 0) {
        success = cmd_rail2(args, &caller);
    }
    else if (strcmp(firstWord, "goto") == 0) {
        success = cmd_goto(args, &caller);
    }
    else if (strcmp(firstWord, "jog") == 0) {
        success = cmd_jog(args, &caller);
    }
    else if (strcmp(firstWord, "encoder") == 0) {
        success = cmd_encoder(args, &caller);
    }
    else if (strcmp(firstWord, "teach") == 0) {
        success = cmd_teach(args, &caller);
    }
    else if (strcmp(firstWord, "labware") == 0) {
        success = cmd_labware(args, &caller);
    }
    else if (strcmp(firstWord, "log") == 0) {
        success = cmd_log(args, &caller);
    }
    else if (strcmp(firstWord, "system") == 0) {
        success = cmd_system(args, &caller);
    }
    else if (strcmp(firstWord, "help") == 0 || strcmp(firstWord, "h") == 0) {
        success = cmd_print_help(args, &caller);
    }
    else if (strcmp(firstWord, "network") == 0) {
        success = cmd_network(args, &caller);
    }
    else {
        output->println("[ERROR] Command not recognized");
        success = false;
    }

    return success;
}

//=============================================================================
// TEST HARNESS
//=============================================================================

int main() {
    // Test commands from your list
    std::vector<std::string> testCommands = {
        "rail1,home",
        "rail1,move-wc1,no-labware",
        "rail1,move-wc1,with-labware",
        "rail1,move-wc2,no-labware",
        "rail1,move-wc2,with-labware",
        "rail1,move-staging,no-labware",
        "rail1,move-staging,with-labware",
        "rail1,move-handoff,no-labware",
        "rail1,move-handoff,with-labware",
        "rail1,move-mm-to,X,no-labware",
        "rail1,move-mm-to,X,with-labware",
        "rail1,move-rel,X,no-labware",
        "rail1,move-rel,X,with-labware",
        "rail1,status",
        "rail1,help",
        "rail2,init",
        "rail2,clear-fault",
        "rail2,abort",
        "rail2,stop",
        "rail2,extend",
        "rail2,retract",
        "rail2,home",
        "rail2,move-wc3,no-labware",
        "rail2,move-wc3,with-labware",
        "rail2,move-handoff,no-labware",
        "rail2,move-handoff,with-labware",
        "rail2,move-mm-to,X,no-labware",
        "rail2,move-mm-to,X,with-labware",
        "rail2,move-rel,X,no-labware",
        "rail2,move-rel,X,with-labware",
        "rail2,status",
        "rail2,help",
        "teach,rail1,position1",
        "teach,rail1,status",
        "teach,status",
        "teach,rail1,reset",
        "teach,reset",
        "network,status",
        "network,disconnect",
        "network,help",
        "jog,rail1,+",
        "jog,rail1,-",
        "jog,rail1,+,5",
        "jog,rail1,-,5",
        "jog,rail1,increment,1",
        "jog,rail1,speed,100",
        "jog,rail1,status",
        "jog,status",
        "jog,help",
        "encoder,enable,rail1",
        "encoder,disable",
        "encoder,multiplier,2",
        "encoder,velocity,50",
        "encoder,status",
        "encoder,help",
        "system,state",
        "system,home",
        "system,reset",
        "system,help",
        "goto,wc1,with-labware",
        "goto,wc2,no-labware",
        "goto,wc3,with-labware",
        "goto,help",
        "labware,status",
        "labware,audit",
        "labware,reset",
        "labware,help",
        "log,on,5",
        "log,off",
        "log,now",
        "log,history",
        "log,errors",
        "log,last,10",
        "log,stats",
        "log,help",
        "help",
        "invalid_command_test"
    };

    std::cout << "=============================================================================\n";
    std::cout << "COMMAND EXECUTION SIMULATION TEST\n";
    std::cout << "Testing " << testCommands.size() << " commands\n";
    std::cout << "=============================================================================\n\n";

    int successCount = 0;
    int totalCount = 0;

    for (const auto& command : testCommands) {
        std::cout << "TESTING: " << command << "\n";
        std::cout << "----------------------------------------\n";
        
        MockStream output;
        bool success = simulateExecuteCommand(command.c_str(), &output);
        
        std::cout << output.output;
        std::cout << "SUCCESS: " << (success ? "TRUE" : "FALSE") << "\n";
        std::cout << "========================================\n\n";
        
        if (success) successCount++;
        totalCount++;
    }

    std::cout << "\n=============================================================================\n";
    std::cout << "TEST SUMMARY\n";
    std::cout << "=============================================================================\n";
    std::cout << "Commands tested: " << totalCount << "\n";
    std::cout << "Successful: " << successCount << "\n";
    std::cout << "Failed: " << (totalCount - successCount) << "\n";
    std::cout << "Success rate: " << (100.0 * successCount / totalCount) << "%\n";
    std::cout << "=============================================================================\n";

    return 0;
}
